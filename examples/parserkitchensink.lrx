/*
 * Lorax Parser Kitchen Sink
 *
 * NOT GUARANTEED TO BE SEMANTICALLY ACCURATE
 * For testing parsing abilities. In other words it may parse but it won't compile.
 *
 * Author: Chris D'Angelo
 */

// resulting Abstract Syntax Tree
// program: Ast.program =
//   ([("e",
//      Ast.Lrx_Tree {Ast.datatype = Ast.Lrx_Char; degree = Ast.Int_Literal 1});
//     ("d", Ast.Lrx_Atom Ast.Lrx_Char); ("c", Ast.Lrx_Atom Ast.Lrx_Float);
//     ("b",
//      Ast.Lrx_Tree {Ast.datatype = Ast.Lrx_Float; degree = Ast.Int_Literal 3});
//     ("a", Ast.Lrx_Atom Ast.Lrx_Int)],
//    [{Ast.fname = "main"; ret_type = Ast.Lrx_Atom Ast.Lrx_Int; formals = [];
//      locals =
//       [("g",
//         Ast.Lrx_Tree
//          {Ast.datatype = Ast.Lrx_Float; degree = Ast.Int_Literal 3});
//        ("k",
//         Ast.Lrx_Tree
//          {Ast.datatype = Ast.Lrx_Char; degree = Ast.Int_Literal 2});
//        ("l", Ast.Lrx_Atom Ast.Lrx_Int); ("m", Ast.Lrx_Atom Ast.Lrx_Char);
//        ("s", Ast.Lrx_Atom Ast.Lrx_Bool); ("t", Ast.Lrx_Atom Ast.Lrx_Bool);
//        ("v",
//         Ast.Lrx_Tree
//          {Ast.datatype = Ast.Lrx_Char; degree = Ast.Int_Literal 1});
//        ("z",
//         Ast.Lrx_Tree
//          {Ast.datatype = Ast.Lrx_Char; degree = Ast.Int_Literal 2});
//        ("y", Ast.Lrx_Atom Ast.Lrx_Int)];
//      body =
//       [Ast.Expr (Ast.Assign ("l", Ast.Int_Literal 2));
//        Ast.Expr (Ast.Assign ("a", Ast.Int_Literal 4));
//        Ast.While (Ast.Binop (Ast.Id "l", Ast.Less, Ast.Id "a"),
//         Ast.Block [Ast.Expr (Ast.Call ("inc", [Ast.Id "l"])); Ast.Break]);
//        Ast.Expr (Ast.Assign ("y", Ast.Unop (Ast.Int_Literal 1, Ast.Neg)));
//        Ast.Expr
//         (Ast.Call ("print",
//           [Ast.Binop (Ast.Id "a", Ast.Mod, Ast.Int_Literal 3)]));
//        Ast.Expr
//         (Ast.Assign ("g",
//           Ast.Tree (Ast.Float_Literal 1.1,
//            [Ast.Float_Literal 2.1;
//             Ast.Tree (Ast.Float_Literal 2.2,
//              [Ast.Float_Literal 2.21; Ast.Float_Literal 2.22;
//               Ast.Float_Literal 2.23]);
//             Ast.Tree (Ast.Float_Literal 2.3,
//              [Ast.Float_Literal 2.31; Ast.Float_Literal 2.32])])));
//        Ast.Expr
//         (Ast.Assign ("k",
//           Ast.Tree (Ast.Char_Literal 'z',
//            [Ast.Char_Literal 'x';
//             Ast.Tree (Ast.Char_Literal 'y',
//              [Ast.Char_Literal 'b'; Ast.Char_Literal 'a'])])));
//        Ast.Expr
//         (Ast.Call ("print",
//           [Ast.Call ("capitalize_letter_a",
//             [Ast.Binop (Ast.Binop (Ast.Id "k", Ast.Child, Ast.Int_Literal 1),
//               Ast.Child, Ast.Int_Literal 1)])]));
//        Ast.Expr
//         (Ast.Call ("change_letter_to_q",
//           [Ast.Binop (Ast.Binop (Ast.Id "k", Ast.Child, Ast.Int_Literal 1),
//             Ast.Child, Ast.Int_Literal 1)]));
//        Ast.Expr
//         (Ast.Call ("print",
//           [Ast.Unop
//             (Ast.Binop (Ast.Binop (Ast.Id "k", Ast.Child, Ast.Int_Literal 1),
//               Ast.Child, Ast.Int_Literal 1),
//             Ast.At)]));
//        Ast.Expr (Ast.Call ("change_first_child_letter_to_p", [Ast.Id "k"]));
//        Ast.Expr (Ast.Call ("print", [Ast.Id "k"]));
//        Ast.Expr
//         (Ast.Call ("print",
//           [Ast.Assign ("t",
//             Ast.Binop (Ast.Unop (Ast.Id "s", Ast.Not), Ast.Or,
//              Ast.Binop (Ast.Bool_Literal false, Ast.And,
//               Ast.Bool_Literal true)))]));
//         (Ast.Assign ("z",
//           Ast.Unop
//            (Ast.Binop
//              (Ast.Tree (Ast.Char_Literal 'm',
//                [Ast.Char_Literal 'n'; Ast.Char_Literal 'o']),
//              Ast.Child, Ast.Int_Literal 0),
//            Ast.Pop)));
//        Ast.For (Ast.Assign ("l", Ast.Int_Literal 0),
//         Ast.Binop (Ast.Id "l", Ast.Less, Ast.Int_Literal 42),
//         Ast.Assign ("l", Ast.Binop (Ast.Id "l", Ast.Add, Ast.Int_Literal 1)),
//         Ast.Block [Ast.Expr (Ast.Call ("print", [Ast.Id "l"]))])]}])

// parsing requires global variables must be declared first
int a;
tree <float>b(3);
float c;
char d;
string e;

int inc (int x) {
	return x + 1;
}

char capitalize_letter_a (char a) {
	if (a == 'a') {
		return 'A';
	}
	return '0';
}

int change_first_child_letter_to_p(tree <char>r(2)) {
	r%(1-1)@ = 'w'; // for fun
	// r%1-1@ = 'w'; // this is acceptable syntax but not semantics
	r%0@ = 'p';
	return 0;
}

int change_letter_to_q(tree <char>n(2)) {
	n@ = 'q';
	return 0;
}

int print_for_me_please(string s)
{
	print(s + "\n");
}

int capitalize_all_of_me(string s)
{
	string tmp;
	tmp = s;
	while (tmp%0 != null) {
		if (tmp@ < 'z') {
			// lowercase
			tmp@ = tmp@ + 'A' - 'a';
		}
		tmp = tmp%0;
	}
	return 0;
}

int main() {
	// parsing requires function locals must be declared first
	tree <float>g(3);
	tree <char>k(2);
	int l;
	char m;
	bool s;
	bool t;
	string v;
	tree <char>z(2);
	int y;
	l = 2;
	a = 4;

	while (l < a) {
		inc(l);
		break;
	}
	y = -1;
	print(a mod 3);
	g = 1.1[2.1, 2.2[2.21, 2.22, 2.23], 2.3[2.31, 2.32]];

	k = 'z'['x', 'y'['b', 'a']];
	print(capitalize_letter_a(k%1%1));

	change_letter_to_q(k%1%1);
	print(k%1%1@); // should print 0 and tree should be 'z'['x', 'q'['b', 'a']];
	change_first_child_letter_to_p(k);
	print(k); // should print 0 and tree should be 'z'['p', 'q'['b', 'a']];

	print(t = (!s || false && true));

	print_for_me_please("hello");

	v = "hello";
	capitalize_all_of_me(v);
	print(v);

	z = k + 'm'['n', 'o']; // will give 'a' a child 'm' (which itself has two children)

	z%1--; // pop the second (ref: 1) child off of z
	z = 'm'['n', 'o']--; // will nullify this tree
	z = 'm'['n', 'o']%0--; // will pop the 'n' from the tree

	for (l = 0; l < 42; l = l + 1) {
		print(l);
	}

	a = b = c;


}










